// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robogen.proto

#include "robogen.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Body_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BodyConnection_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BodyPart_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Brain_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EvolvableParameter_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LightSource_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NeuralConnection_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Neuron_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Obstacle_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Robot_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_SimulatorConf_robogen_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_robogen_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StartPosition_robogen_2eproto;
namespace robogenMessage {
class EvolvableParameterDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EvolvableParameter> _instance;
} _EvolvableParameter_default_instance_;
class BodyPartDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BodyPart> _instance;
} _BodyPart_default_instance_;
class BodyConnectionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<BodyConnection> _instance;
} _BodyConnection_default_instance_;
class BodyDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Body> _instance;
} _Body_default_instance_;
class NeuralConnectionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<NeuralConnection> _instance;
} _NeuralConnection_default_instance_;
class NeuronDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Neuron> _instance;
} _Neuron_default_instance_;
class BrainDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Brain> _instance;
} _Brain_default_instance_;
class RobotDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Robot> _instance;
} _Robot_default_instance_;
class ObstacleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Obstacle> _instance;
} _Obstacle_default_instance_;
class LightSourceDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LightSource> _instance;
} _LightSource_default_instance_;
class StartPositionDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<StartPosition> _instance;
} _StartPosition_default_instance_;
class SimulatorConfDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<SimulatorConf> _instance;
} _SimulatorConf_default_instance_;
class EvaluationRequestDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EvaluationRequest> _instance;
} _EvaluationRequest_default_instance_;
class EvaluationResultDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<EvaluationResult> _instance;
} _EvaluationResult_default_instance_;
}  // namespace robogenMessage
static void InitDefaultsscc_info_Body_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_Body_default_instance_;
    new (ptr) ::robogenMessage::Body();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::Body::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Body_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Body_robogen_2eproto}, {
      &scc_info_BodyPart_robogen_2eproto.base,
      &scc_info_BodyConnection_robogen_2eproto.base,}};

static void InitDefaultsscc_info_BodyConnection_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_BodyConnection_default_instance_;
    new (ptr) ::robogenMessage::BodyConnection();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::BodyConnection::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_BodyConnection_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_BodyConnection_robogen_2eproto}, {}};

static void InitDefaultsscc_info_BodyPart_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_BodyPart_default_instance_;
    new (ptr) ::robogenMessage::BodyPart();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::BodyPart::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_BodyPart_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_BodyPart_robogen_2eproto}, {
      &scc_info_EvolvableParameter_robogen_2eproto.base,}};

static void InitDefaultsscc_info_Brain_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_Brain_default_instance_;
    new (ptr) ::robogenMessage::Brain();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::Brain::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Brain_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Brain_robogen_2eproto}, {
      &scc_info_Neuron_robogen_2eproto.base,
      &scc_info_NeuralConnection_robogen_2eproto.base,}};

static void InitDefaultsscc_info_EvaluationRequest_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_EvaluationRequest_default_instance_;
    new (ptr) ::robogenMessage::EvaluationRequest();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::EvaluationRequest::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_EvaluationRequest_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_EvaluationRequest_robogen_2eproto}, {
      &scc_info_Robot_robogen_2eproto.base,
      &scc_info_SimulatorConf_robogen_2eproto.base,}};

static void InitDefaultsscc_info_EvaluationResult_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_EvaluationResult_default_instance_;
    new (ptr) ::robogenMessage::EvaluationResult();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::EvaluationResult::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EvaluationResult_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EvaluationResult_robogen_2eproto}, {}};

static void InitDefaultsscc_info_EvolvableParameter_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_EvolvableParameter_default_instance_;
    new (ptr) ::robogenMessage::EvolvableParameter();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::EvolvableParameter::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_EvolvableParameter_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_EvolvableParameter_robogen_2eproto}, {}};

static void InitDefaultsscc_info_LightSource_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_LightSource_default_instance_;
    new (ptr) ::robogenMessage::LightSource();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::LightSource::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_LightSource_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_LightSource_robogen_2eproto}, {}};

static void InitDefaultsscc_info_NeuralConnection_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_NeuralConnection_default_instance_;
    new (ptr) ::robogenMessage::NeuralConnection();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::NeuralConnection::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_NeuralConnection_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_NeuralConnection_robogen_2eproto}, {}};

static void InitDefaultsscc_info_Neuron_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_Neuron_default_instance_;
    new (ptr) ::robogenMessage::Neuron();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::Neuron::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Neuron_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Neuron_robogen_2eproto}, {}};

static void InitDefaultsscc_info_Obstacle_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_Obstacle_default_instance_;
    new (ptr) ::robogenMessage::Obstacle();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::Obstacle::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Obstacle_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Obstacle_robogen_2eproto}, {}};

static void InitDefaultsscc_info_Robot_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_Robot_default_instance_;
    new (ptr) ::robogenMessage::Robot();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::Robot::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_Robot_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, 0, InitDefaultsscc_info_Robot_robogen_2eproto}, {
      &scc_info_Body_robogen_2eproto.base,
      &scc_info_Brain_robogen_2eproto.base,}};

static void InitDefaultsscc_info_SimulatorConf_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_SimulatorConf_default_instance_;
    new (ptr) ::robogenMessage::SimulatorConf();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::SimulatorConf::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<3> scc_info_SimulatorConf_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 3, 0, InitDefaultsscc_info_SimulatorConf_robogen_2eproto}, {
      &scc_info_Obstacle_robogen_2eproto.base,
      &scc_info_LightSource_robogen_2eproto.base,
      &scc_info_StartPosition_robogen_2eproto.base,}};

static void InitDefaultsscc_info_StartPosition_robogen_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::robogenMessage::_StartPosition_default_instance_;
    new (ptr) ::robogenMessage::StartPosition();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::robogenMessage::StartPosition::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_StartPosition_robogen_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_StartPosition_robogen_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_robogen_2eproto[14];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_robogen_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_robogen_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_robogen_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvolvableParameter, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvolvableParameter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvolvableParameter, paramvalue_),
  0,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyPart, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyPart, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyPart, id_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyPart, type_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyPart, root_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyPart, evolvableparam_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyPart, orientation_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyConnection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyConnection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyConnection, src_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyConnection, dest_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyConnection, srcslot_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::BodyConnection, destslot_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Body, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Body, part_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Body, connection_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::NeuralConnection, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::NeuralConnection, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::NeuralConnection, src_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::NeuralConnection, dest_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::NeuralConnection, weight_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, id_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, layer_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, type_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, bias_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, bodypartid_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, ioid_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, tau_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, phaseoffset_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, period_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Neuron, gain_),
  0,
  1,
  2,
  4,
  3,
  5,
  6,
  7,
  8,
  9,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Brain, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Brain, neuron_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Brain, connection_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Robot, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Robot, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Robot, id_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Robot, body_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Robot, brain_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, x_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, y_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, z_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, xsize_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, ysize_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, zsize_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, density_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, xrotation_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, yrotation_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, zrotation_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::Obstacle, rotationangle_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::LightSource, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::LightSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::LightSource, x_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::LightSource, y_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::LightSource, z_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::LightSource, intensity_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::StartPosition, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::StartPosition, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::StartPosition, x_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::StartPosition, y_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::StartPosition, azimuth_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, terrainwidth_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, terrainlength_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, obstacles_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, scenario_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, lightsources_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, timestep_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, ntimesteps_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, startpositions_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, actuationperiod_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, terrainfriction_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, sensornoiselevel_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, motornoiselevel_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, capacceleration_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, maxlinearacceleration_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, maxangularacceleration_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, maxdirectionshiftspersecond_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, gravityx_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, gravityy_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, gravityz_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, terraintype_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, terrainheight_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, terrainheightfieldfilename_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, disallowobstaclecollisions_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::SimulatorConf, obstacleoverlappolicy_),
  2,
  3,
  ~0u,
  0,
  ~0u,
  4,
  5,
  ~0u,
  6,
  7,
  8,
  9,
  15,
  10,
  11,
  12,
  13,
  14,
  17,
  18,
  19,
  1,
  16,
  20,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationRequest, robot_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationRequest, configuration_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationResult, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationResult, id_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationResult, fitness_),
  PROTOBUF_FIELD_OFFSET(::robogenMessage::EvaluationResult, objectives_),
  0,
  1,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 6, sizeof(::robogenMessage::EvolvableParameter)},
  { 7, 17, sizeof(::robogenMessage::BodyPart)},
  { 22, 31, sizeof(::robogenMessage::BodyConnection)},
  { 35, -1, sizeof(::robogenMessage::Body)},
  { 42, 50, sizeof(::robogenMessage::NeuralConnection)},
  { 53, 68, sizeof(::robogenMessage::Neuron)},
  { 78, -1, sizeof(::robogenMessage::Brain)},
  { 85, 93, sizeof(::robogenMessage::Robot)},
  { 96, 112, sizeof(::robogenMessage::Obstacle)},
  { 123, 132, sizeof(::robogenMessage::LightSource)},
  { 136, 144, sizeof(::robogenMessage::StartPosition)},
  { 147, 176, sizeof(::robogenMessage::SimulatorConf)},
  { 200, 207, sizeof(::robogenMessage::EvaluationRequest)},
  { 209, 217, sizeof(::robogenMessage::EvaluationResult)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_EvolvableParameter_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_BodyPart_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_BodyConnection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_Body_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_NeuralConnection_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_Neuron_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_Brain_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_Robot_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_Obstacle_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_LightSource_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_StartPosition_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_SimulatorConf_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_EvaluationRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::robogenMessage::_EvaluationResult_default_instance_),
};

const char descriptor_table_protodef_robogen_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\rrobogen.proto\022\016robogenMessage\"(\n\022Evolv"
  "ableParameter\022\022\n\nparamValue\030\001 \002(\002\"\203\001\n\010Bo"
  "dyPart\022\n\n\002id\030\001 \002(\t\022\014\n\004type\030\002 \002(\t\022\014\n\004root"
  "\030\003 \002(\010\022:\n\016evolvableParam\030\004 \003(\0132\".robogen"
  "Message.EvolvableParameter\022\023\n\013orientatio"
  "n\030\005 \002(\005\"N\n\016BodyConnection\022\013\n\003src\030\001 \002(\t\022\014"
  "\n\004dest\030\002 \002(\t\022\017\n\007srcSlot\030\003 \002(\005\022\020\n\010destSlo"
  "t\030\004 \002(\005\"b\n\004Body\022&\n\004part\030\001 \003(\0132\030.robogenM"
  "essage.BodyPart\0222\n\nconnection\030\002 \003(\0132\036.ro"
  "bogenMessage.BodyConnection\"=\n\020NeuralCon"
  "nection\022\013\n\003src\030\001 \002(\t\022\014\n\004dest\030\002 \002(\t\022\016\n\006we"
  "ight\030\003 \002(\002\"\241\001\n\006Neuron\022\n\n\002id\030\001 \002(\t\022\r\n\005lay"
  "er\030\002 \002(\t\022\014\n\004type\030\003 \002(\t\022\014\n\004bias\030\004 \001(\002\022\022\n\n"
  "bodyPartId\030\005 \001(\t\022\014\n\004ioId\030\006 \001(\005\022\013\n\003tau\030\007 "
  "\001(\002\022\023\n\013phaseOffset\030\010 \001(\002\022\016\n\006period\030\t \001(\002"
  "\022\014\n\004gain\030\n \001(\002\"e\n\005Brain\022&\n\006neuron\030\001 \003(\0132"
  "\026.robogenMessage.Neuron\0224\n\nconnection\030\002 "
  "\003(\0132 .robogenMessage.NeuralConnection\"]\n"
  "\005Robot\022\n\n\002id\030\001 \002(\005\022\"\n\004body\030\002 \002(\0132\024.robog"
  "enMessage.Body\022$\n\005brain\030\003 \002(\0132\025.robogenM"
  "essage.Brain\"\271\001\n\010Obstacle\022\t\n\001x\030\001 \002(\002\022\t\n\001"
  "y\030\002 \002(\002\022\t\n\001z\030\003 \002(\002\022\r\n\005xSize\030\004 \002(\002\022\r\n\005ySi"
  "ze\030\005 \002(\002\022\r\n\005zSize\030\006 \002(\002\022\017\n\007density\030\007 \002(\002"
  "\022\021\n\txRotation\030\010 \002(\002\022\021\n\tyRotation\030\t \002(\002\022\021"
  "\n\tzRotation\030\n \002(\002\022\025\n\rrotationAngle\030\013 \002(\002"
  "\"A\n\013LightSource\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\t\n"
  "\001z\030\003 \002(\002\022\021\n\tintensity\030\007 \002(\002\"6\n\rStartPosi"
  "tion\022\t\n\001x\030\001 \002(\002\022\t\n\001y\030\002 \002(\002\022\017\n\007azimuth\030\003 "
  "\002(\002\"\266\005\n\rSimulatorConf\022\024\n\014terrainWidth\030\001 "
  "\002(\002\022\025\n\rterrainLength\030\002 \002(\002\022+\n\tobstacles\030"
  "\003 \003(\0132\030.robogenMessage.Obstacle\022\020\n\010scena"
  "rio\030\004 \002(\t\0221\n\014lightSources\030\005 \003(\0132\033.roboge"
  "nMessage.LightSource\022\020\n\010timeStep\030\006 \002(\002\022\022"
  "\n\nnTimeSteps\030\007 \002(\005\0225\n\016startPositions\030\010 \003"
  "(\0132\035.robogenMessage.StartPosition\022\027\n\017act"
  "uationPeriod\030\t \002(\005\022\027\n\017terrainFriction\030\n "
  "\002(\002\022\030\n\020sensorNoiseLevel\030\013 \002(\002\022\027\n\017motorNo"
  "iseLevel\030\014 \002(\002\022\027\n\017capAcceleration\030\r \002(\010\022"
  "\035\n\025maxLinearAcceleration\030\016 \002(\002\022\036\n\026maxAng"
  "ularAcceleration\030\017 \002(\002\022#\n\033maxDirectionSh"
  "iftsPerSecond\030\020 \002(\005\022\020\n\010gravityX\030\021 \002(\002\022\020\n"
  "\010gravityY\030\022 \002(\002\022\020\n\010gravityZ\030\023 \002(\002\022\023\n\013ter"
  "rainType\030\024 \002(\005\022\025\n\rterrainHeight\030\025 \002(\002\022\"\n"
  "\032terrainHeightFieldFileName\030\026 \002(\t\022\"\n\032dis"
  "allowObstacleCollisions\030\027 \002(\010\022\035\n\025obstacl"
  "eOverlapPolicy\030\030 \002(\r\"o\n\021EvaluationReques"
  "t\022$\n\005robot\030\001 \002(\0132\025.robogenMessage.Robot\022"
  "4\n\rconfiguration\030\002 \002(\0132\035.robogenMessage."
  "SimulatorConf\"C\n\020EvaluationResult\022\n\n\002id\030"
  "\001 \002(\005\022\017\n\007fitness\030\002 \002(\002\022\022\n\nobjectives\030\003 \003"
  "(\002"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_robogen_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_robogen_2eproto_sccs[14] = {
  &scc_info_Body_robogen_2eproto.base,
  &scc_info_BodyConnection_robogen_2eproto.base,
  &scc_info_BodyPart_robogen_2eproto.base,
  &scc_info_Brain_robogen_2eproto.base,
  &scc_info_EvaluationRequest_robogen_2eproto.base,
  &scc_info_EvaluationResult_robogen_2eproto.base,
  &scc_info_EvolvableParameter_robogen_2eproto.base,
  &scc_info_LightSource_robogen_2eproto.base,
  &scc_info_NeuralConnection_robogen_2eproto.base,
  &scc_info_Neuron_robogen_2eproto.base,
  &scc_info_Obstacle_robogen_2eproto.base,
  &scc_info_Robot_robogen_2eproto.base,
  &scc_info_SimulatorConf_robogen_2eproto.base,
  &scc_info_StartPosition_robogen_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_robogen_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robogen_2eproto = {
  false, false, descriptor_table_protodef_robogen_2eproto, "robogen.proto", 2002,
  &descriptor_table_robogen_2eproto_once, descriptor_table_robogen_2eproto_sccs, descriptor_table_robogen_2eproto_deps, 14, 0,
  schemas, file_default_instances, TableStruct_robogen_2eproto::offsets,
  file_level_metadata_robogen_2eproto, 14, file_level_enum_descriptors_robogen_2eproto, file_level_service_descriptors_robogen_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_robogen_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_robogen_2eproto)), true);
namespace robogenMessage {

// ===================================================================

void EvolvableParameter::InitAsDefaultInstance() {
}
class EvolvableParameter::_Internal {
 public:
  using HasBits = decltype(std::declval<EvolvableParameter>()._has_bits_);
  static void set_has_paramvalue(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

EvolvableParameter::EvolvableParameter(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.EvolvableParameter)
}
EvolvableParameter::EvolvableParameter(const EvolvableParameter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  paramvalue_ = from.paramvalue_;
  // @@protoc_insertion_point(copy_constructor:robogenMessage.EvolvableParameter)
}

void EvolvableParameter::SharedCtor() {
  paramvalue_ = 0;
}

EvolvableParameter::~EvolvableParameter() {
  // @@protoc_insertion_point(destructor:robogenMessage.EvolvableParameter)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EvolvableParameter::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EvolvableParameter::ArenaDtor(void* object) {
  EvolvableParameter* _this = reinterpret_cast< EvolvableParameter* >(object);
  (void)_this;
}
void EvolvableParameter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EvolvableParameter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EvolvableParameter& EvolvableParameter::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EvolvableParameter_robogen_2eproto.base);
  return *internal_default_instance();
}


void EvolvableParameter::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.EvolvableParameter)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  paramvalue_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EvolvableParameter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float paramValue = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_paramvalue(&has_bits);
          paramvalue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EvolvableParameter::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.EvolvableParameter)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float paramValue = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_paramvalue(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.EvolvableParameter)
  return target;
}

size_t EvolvableParameter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.EvolvableParameter)
  size_t total_size = 0;

  // required float paramValue = 1;
  if (_internal_has_paramvalue()) {
    total_size += 1 + 4;
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EvolvableParameter::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.EvolvableParameter)
  GOOGLE_DCHECK_NE(&from, this);
  const EvolvableParameter* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EvolvableParameter>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.EvolvableParameter)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.EvolvableParameter)
    MergeFrom(*source);
  }
}

void EvolvableParameter::MergeFrom(const EvolvableParameter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.EvolvableParameter)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_paramvalue()) {
    _internal_set_paramvalue(from._internal_paramvalue());
  }
}

void EvolvableParameter::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.EvolvableParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EvolvableParameter::CopyFrom(const EvolvableParameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.EvolvableParameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EvolvableParameter::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EvolvableParameter::InternalSwap(EvolvableParameter* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(paramvalue_, other->paramvalue_);
}

::PROTOBUF_NAMESPACE_ID::Metadata EvolvableParameter::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BodyPart::InitAsDefaultInstance() {
}
class BodyPart::_Internal {
 public:
  using HasBits = decltype(std::declval<BodyPart>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_root(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_orientation(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

BodyPart::BodyPart(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  evolvableparam_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.BodyPart)
}
BodyPart::BodyPart(const BodyPart& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      evolvableparam_(from.evolvableparam_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_id(),
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  ::memcpy(&root_, &from.root_,
    static_cast<size_t>(reinterpret_cast<char*>(&orientation_) -
    reinterpret_cast<char*>(&root_)) + sizeof(orientation_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.BodyPart)
}

void BodyPart::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BodyPart_robogen_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&root_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&orientation_) -
      reinterpret_cast<char*>(&root_)) + sizeof(orientation_));
}

BodyPart::~BodyPart() {
  // @@protoc_insertion_point(destructor:robogenMessage.BodyPart)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BodyPart::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BodyPart::ArenaDtor(void* object) {
  BodyPart* _this = reinterpret_cast< BodyPart* >(object);
  (void)_this;
}
void BodyPart::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BodyPart::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BodyPart& BodyPart::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BodyPart_robogen_2eproto.base);
  return *internal_default_instance();
}


void BodyPart::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.BodyPart)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  evolvableparam_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      type_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&root_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&orientation_) -
        reinterpret_cast<char*>(&root_)) + sizeof(orientation_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BodyPart::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.BodyPart.id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.BodyPart.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool root = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_root(&has_bits);
          root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .robogenMessage.EvolvableParameter evolvableParam = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_evolvableparam(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else goto handle_unusual;
        continue;
      // required int32 orientation = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_orientation(&has_bits);
          orientation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BodyPart::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.BodyPart)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.BodyPart.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // required string type = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.BodyPart.type");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_type(), target);
  }

  // required bool root = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_root(), target);
  }

  // repeated .robogenMessage.EvolvableParameter evolvableParam = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_evolvableparam_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_evolvableparam(i), target, stream);
  }

  // required int32 orientation = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_orientation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.BodyPart)
  return target;
}

size_t BodyPart::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.BodyPart)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  if (_internal_has_type()) {
    // required string type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  if (_internal_has_root()) {
    // required bool root = 3;
    total_size += 1 + 1;
  }

  if (_internal_has_orientation()) {
    // required int32 orientation = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_orientation());
  }

  return total_size;
}
size_t BodyPart::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.BodyPart)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());

    // required string type = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());

    // required bool root = 3;
    total_size += 1 + 1;

    // required int32 orientation = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_orientation());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .robogenMessage.EvolvableParameter evolvableParam = 4;
  total_size += 1UL * this->_internal_evolvableparam_size();
  for (const auto& msg : this->evolvableparam_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BodyPart::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.BodyPart)
  GOOGLE_DCHECK_NE(&from, this);
  const BodyPart* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BodyPart>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.BodyPart)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.BodyPart)
    MergeFrom(*source);
  }
}

void BodyPart::MergeFrom(const BodyPart& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.BodyPart)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  evolvableparam_.MergeFrom(from.evolvableparam_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000004u) {
      root_ = from.root_;
    }
    if (cached_has_bits & 0x00000008u) {
      orientation_ = from.orientation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BodyPart::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.BodyPart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BodyPart::CopyFrom(const BodyPart& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.BodyPart)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BodyPart::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(evolvableparam_)) return false;
  return true;
}

void BodyPart::InternalSwap(BodyPart* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  evolvableparam_.InternalSwap(&other->evolvableparam_);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BodyPart, orientation_)
      + sizeof(BodyPart::orientation_)
      - PROTOBUF_FIELD_OFFSET(BodyPart, root_)>(
          reinterpret_cast<char*>(&root_),
          reinterpret_cast<char*>(&other->root_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BodyPart::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void BodyConnection::InitAsDefaultInstance() {
}
class BodyConnection::_Internal {
 public:
  using HasBits = decltype(std::declval<BodyConnection>()._has_bits_);
  static void set_has_src(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dest(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_srcslot(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_destslot(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

BodyConnection::BodyConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.BodyConnection)
}
BodyConnection::BodyConnection(const BodyConnection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  src_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_src()) {
    src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_src(),
      GetArena());
  }
  dest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_dest()) {
    dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_dest(),
      GetArena());
  }
  ::memcpy(&srcslot_, &from.srcslot_,
    static_cast<size_t>(reinterpret_cast<char*>(&destslot_) -
    reinterpret_cast<char*>(&srcslot_)) + sizeof(destslot_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.BodyConnection)
}

void BodyConnection::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_BodyConnection_robogen_2eproto.base);
  src_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  dest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&srcslot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&destslot_) -
      reinterpret_cast<char*>(&srcslot_)) + sizeof(destslot_));
}

BodyConnection::~BodyConnection() {
  // @@protoc_insertion_point(destructor:robogenMessage.BodyConnection)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void BodyConnection::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  src_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  dest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void BodyConnection::ArenaDtor(void* object) {
  BodyConnection* _this = reinterpret_cast< BodyConnection* >(object);
  (void)_this;
}
void BodyConnection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void BodyConnection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const BodyConnection& BodyConnection::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_BodyConnection_robogen_2eproto.base);
  return *internal_default_instance();
}


void BodyConnection::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.BodyConnection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      src_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      dest_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&srcslot_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&destslot_) -
        reinterpret_cast<char*>(&srcslot_)) + sizeof(destslot_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BodyConnection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string src = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_src();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.BodyConnection.src");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string dest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_dest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.BodyConnection.dest");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 srcSlot = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_srcslot(&has_bits);
          srcslot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required int32 destSlot = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_destslot(&has_bits);
          destslot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* BodyConnection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.BodyConnection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string src = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_src().data(), static_cast<int>(this->_internal_src().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.BodyConnection.src");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_src(), target);
  }

  // required string dest = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dest().data(), static_cast<int>(this->_internal_dest().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.BodyConnection.dest");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_dest(), target);
  }

  // required int32 srcSlot = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_srcslot(), target);
  }

  // required int32 destSlot = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_destslot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.BodyConnection)
  return target;
}

size_t BodyConnection::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.BodyConnection)
  size_t total_size = 0;

  if (_internal_has_src()) {
    // required string src = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_src());
  }

  if (_internal_has_dest()) {
    // required string dest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dest());
  }

  if (_internal_has_srcslot()) {
    // required int32 srcSlot = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_srcslot());
  }

  if (_internal_has_destslot()) {
    // required int32 destSlot = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_destslot());
  }

  return total_size;
}
size_t BodyConnection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.BodyConnection)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string src = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_src());

    // required string dest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dest());

    // required int32 srcSlot = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_srcslot());

    // required int32 destSlot = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_destslot());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BodyConnection::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.BodyConnection)
  GOOGLE_DCHECK_NE(&from, this);
  const BodyConnection* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<BodyConnection>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.BodyConnection)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.BodyConnection)
    MergeFrom(*source);
  }
}

void BodyConnection::MergeFrom(const BodyConnection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.BodyConnection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_src(from._internal_src());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_dest(from._internal_dest());
    }
    if (cached_has_bits & 0x00000004u) {
      srcslot_ = from.srcslot_;
    }
    if (cached_has_bits & 0x00000008u) {
      destslot_ = from.destslot_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void BodyConnection::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.BodyConnection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BodyConnection::CopyFrom(const BodyConnection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.BodyConnection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BodyConnection::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void BodyConnection::InternalSwap(BodyConnection* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  src_.Swap(&other->src_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  dest_.Swap(&other->dest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BodyConnection, destslot_)
      + sizeof(BodyConnection::destslot_)
      - PROTOBUF_FIELD_OFFSET(BodyConnection, srcslot_)>(
          reinterpret_cast<char*>(&srcslot_),
          reinterpret_cast<char*>(&other->srcslot_));
}

::PROTOBUF_NAMESPACE_ID::Metadata BodyConnection::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Body::InitAsDefaultInstance() {
}
class Body::_Internal {
 public:
};

Body::Body(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  part_(arena),
  connection_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.Body)
}
Body::Body(const Body& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      part_(from.part_),
      connection_(from.connection_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:robogenMessage.Body)
}

void Body::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Body_robogen_2eproto.base);
}

Body::~Body() {
  // @@protoc_insertion_point(destructor:robogenMessage.Body)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Body::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Body::ArenaDtor(void* object) {
  Body* _this = reinterpret_cast< Body* >(object);
  (void)_this;
}
void Body::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Body::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Body& Body::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Body_robogen_2eproto.base);
  return *internal_default_instance();
}


void Body::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.Body)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  part_.Clear();
  connection_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Body::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .robogenMessage.BodyPart part = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_part(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .robogenMessage.BodyConnection connection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_connection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Body::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.Body)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .robogenMessage.BodyPart part = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_part_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_part(i), target, stream);
  }

  // repeated .robogenMessage.BodyConnection connection = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_connection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_connection(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.Body)
  return target;
}

size_t Body::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.Body)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .robogenMessage.BodyPart part = 1;
  total_size += 1UL * this->_internal_part_size();
  for (const auto& msg : this->part_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .robogenMessage.BodyConnection connection = 2;
  total_size += 1UL * this->_internal_connection_size();
  for (const auto& msg : this->connection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Body::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.Body)
  GOOGLE_DCHECK_NE(&from, this);
  const Body* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Body>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.Body)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.Body)
    MergeFrom(*source);
  }
}

void Body::MergeFrom(const Body& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.Body)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  part_.MergeFrom(from.part_);
  connection_.MergeFrom(from.connection_);
}

void Body::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.Body)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Body::CopyFrom(const Body& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.Body)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Body::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(part_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(connection_)) return false;
  return true;
}

void Body::InternalSwap(Body* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  part_.InternalSwap(&other->part_);
  connection_.InternalSwap(&other->connection_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Body::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void NeuralConnection::InitAsDefaultInstance() {
}
class NeuralConnection::_Internal {
 public:
  using HasBits = decltype(std::declval<NeuralConnection>()._has_bits_);
  static void set_has_src(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dest(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

NeuralConnection::NeuralConnection(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.NeuralConnection)
}
NeuralConnection::NeuralConnection(const NeuralConnection& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  src_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_src()) {
    src_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_src(),
      GetArena());
  }
  dest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_dest()) {
    dest_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_dest(),
      GetArena());
  }
  weight_ = from.weight_;
  // @@protoc_insertion_point(copy_constructor:robogenMessage.NeuralConnection)
}

void NeuralConnection::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_NeuralConnection_robogen_2eproto.base);
  src_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  dest_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  weight_ = 0;
}

NeuralConnection::~NeuralConnection() {
  // @@protoc_insertion_point(destructor:robogenMessage.NeuralConnection)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void NeuralConnection::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  src_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  dest_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void NeuralConnection::ArenaDtor(void* object) {
  NeuralConnection* _this = reinterpret_cast< NeuralConnection* >(object);
  (void)_this;
}
void NeuralConnection::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void NeuralConnection::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const NeuralConnection& NeuralConnection::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_NeuralConnection_robogen_2eproto.base);
  return *internal_default_instance();
}


void NeuralConnection::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.NeuralConnection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      src_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      dest_.ClearNonDefaultToEmpty();
    }
  }
  weight_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* NeuralConnection::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string src = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_src();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.NeuralConnection.src");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string dest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_dest();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.NeuralConnection.dest");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float weight = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_weight(&has_bits);
          weight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* NeuralConnection::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.NeuralConnection)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string src = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_src().data(), static_cast<int>(this->_internal_src().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.NeuralConnection.src");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_src(), target);
  }

  // required string dest = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dest().data(), static_cast<int>(this->_internal_dest().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.NeuralConnection.dest");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_dest(), target);
  }

  // required float weight = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_weight(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.NeuralConnection)
  return target;
}

size_t NeuralConnection::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.NeuralConnection)
  size_t total_size = 0;

  if (_internal_has_src()) {
    // required string src = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_src());
  }

  if (_internal_has_dest()) {
    // required string dest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dest());
  }

  if (_internal_has_weight()) {
    // required float weight = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t NeuralConnection::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.NeuralConnection)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string src = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_src());

    // required string dest = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_dest());

    // required float weight = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NeuralConnection::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.NeuralConnection)
  GOOGLE_DCHECK_NE(&from, this);
  const NeuralConnection* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<NeuralConnection>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.NeuralConnection)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.NeuralConnection)
    MergeFrom(*source);
  }
}

void NeuralConnection::MergeFrom(const NeuralConnection& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.NeuralConnection)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_src(from._internal_src());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_dest(from._internal_dest());
    }
    if (cached_has_bits & 0x00000004u) {
      weight_ = from.weight_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void NeuralConnection::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.NeuralConnection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NeuralConnection::CopyFrom(const NeuralConnection& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.NeuralConnection)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NeuralConnection::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void NeuralConnection::InternalSwap(NeuralConnection* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  src_.Swap(&other->src_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  dest_.Swap(&other->dest_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(weight_, other->weight_);
}

::PROTOBUF_NAMESPACE_ID::Metadata NeuralConnection::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Neuron::InitAsDefaultInstance() {
}
class Neuron::_Internal {
 public:
  using HasBits = decltype(std::declval<Neuron>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_layer(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_bodypartid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ioid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_tau(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_phaseoffset(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_period(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_gain(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Neuron::Neuron(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.Neuron)
}
Neuron::Neuron(const Neuron& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_id()) {
    id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_id(),
      GetArena());
  }
  layer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_layer()) {
    layer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_layer(),
      GetArena());
  }
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_type()) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_type(),
      GetArena());
  }
  bodypartid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_bodypartid()) {
    bodypartid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_bodypartid(),
      GetArena());
  }
  ::memcpy(&bias_, &from.bias_,
    static_cast<size_t>(reinterpret_cast<char*>(&gain_) -
    reinterpret_cast<char*>(&bias_)) + sizeof(gain_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.Neuron)
}

void Neuron::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Neuron_robogen_2eproto.base);
  id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  layer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  bodypartid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&bias_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&gain_) -
      reinterpret_cast<char*>(&bias_)) + sizeof(gain_));
}

Neuron::~Neuron() {
  // @@protoc_insertion_point(destructor:robogenMessage.Neuron)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Neuron::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  layer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  bodypartid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Neuron::ArenaDtor(void* object) {
  Neuron* _this = reinterpret_cast< Neuron* >(object);
  (void)_this;
}
void Neuron::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Neuron::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Neuron& Neuron::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Neuron_robogen_2eproto.base);
  return *internal_default_instance();
}


void Neuron::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.Neuron)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      layer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      bodypartid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&bias_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&phaseoffset_) -
        reinterpret_cast<char*>(&bias_)) + sizeof(phaseoffset_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&period_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gain_) -
        reinterpret_cast<char*>(&period_)) + sizeof(gain_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Neuron::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required string id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          auto str = _internal_mutable_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.Neuron.id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string layer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_layer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.Neuron.layer");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.Neuron.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float bias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_bias(&has_bits);
          bias_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional string bodyPartId = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          auto str = _internal_mutable_bodypartid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.Neuron.bodyPartId");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional int32 ioId = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_ioid(&has_bits);
          ioid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional float tau = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_tau(&has_bits);
          tau_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float phaseOffset = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_phaseoffset(&has_bits);
          phaseoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float period = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_period(&has_bits);
          period_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // optional float gain = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_gain(&has_bits);
          gain_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Neuron::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.Neuron)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_id().data(), static_cast<int>(this->_internal_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.Neuron.id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_id(), target);
  }

  // required string layer = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_layer().data(), static_cast<int>(this->_internal_layer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.Neuron.layer");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_layer(), target);
  }

  // required string type = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.Neuron.type");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_type(), target);
  }

  // optional float bias = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_bias(), target);
  }

  // optional string bodyPartId = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_bodypartid().data(), static_cast<int>(this->_internal_bodypartid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.Neuron.bodyPartId");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_bodypartid(), target);
  }

  // optional int32 ioId = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_ioid(), target);
  }

  // optional float tau = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_tau(), target);
  }

  // optional float phaseOffset = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_phaseoffset(), target);
  }

  // optional float period = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_period(), target);
  }

  // optional float gain = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_gain(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.Neuron)
  return target;
}

size_t Neuron::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.Neuron)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());
  }

  if (_internal_has_layer()) {
    // required string layer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_layer());
  }

  if (_internal_has_type()) {
    // required string type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());
  }

  return total_size;
}
size_t Neuron::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.Neuron)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_id());

    // required string layer = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_layer());

    // required string type = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000f8u) {
    // optional string bodyPartId = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_bodypartid());
    }

    // optional float bias = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 ioId = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_ioid());
    }

    // optional float tau = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float phaseOffset = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional float period = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float gain = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Neuron::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.Neuron)
  GOOGLE_DCHECK_NE(&from, this);
  const Neuron* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Neuron>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.Neuron)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.Neuron)
    MergeFrom(*source);
  }
}

void Neuron::MergeFrom(const Neuron& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.Neuron)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id(from._internal_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_layer(from._internal_layer());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_bodypartid(from._internal_bodypartid());
    }
    if (cached_has_bits & 0x00000010u) {
      bias_ = from.bias_;
    }
    if (cached_has_bits & 0x00000020u) {
      ioid_ = from.ioid_;
    }
    if (cached_has_bits & 0x00000040u) {
      tau_ = from.tau_;
    }
    if (cached_has_bits & 0x00000080u) {
      phaseoffset_ = from.phaseoffset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      period_ = from.period_;
    }
    if (cached_has_bits & 0x00000200u) {
      gain_ = from.gain_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Neuron::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.Neuron)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Neuron::CopyFrom(const Neuron& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.Neuron)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Neuron::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Neuron::InternalSwap(Neuron* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  id_.Swap(&other->id_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  layer_.Swap(&other->layer_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  type_.Swap(&other->type_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  bodypartid_.Swap(&other->bodypartid_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Neuron, gain_)
      + sizeof(Neuron::gain_)
      - PROTOBUF_FIELD_OFFSET(Neuron, bias_)>(
          reinterpret_cast<char*>(&bias_),
          reinterpret_cast<char*>(&other->bias_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Neuron::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Brain::InitAsDefaultInstance() {
}
class Brain::_Internal {
 public:
};

Brain::Brain(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  neuron_(arena),
  connection_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.Brain)
}
Brain::Brain(const Brain& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      neuron_(from.neuron_),
      connection_(from.connection_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:robogenMessage.Brain)
}

void Brain::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Brain_robogen_2eproto.base);
}

Brain::~Brain() {
  // @@protoc_insertion_point(destructor:robogenMessage.Brain)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Brain::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Brain::ArenaDtor(void* object) {
  Brain* _this = reinterpret_cast< Brain* >(object);
  (void)_this;
}
void Brain::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Brain::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Brain& Brain::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Brain_robogen_2eproto.base);
  return *internal_default_instance();
}


void Brain::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.Brain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  neuron_.Clear();
  connection_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Brain::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .robogenMessage.Neuron neuron = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_neuron(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else goto handle_unusual;
        continue;
      // repeated .robogenMessage.NeuralConnection connection = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_connection(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Brain::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.Brain)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .robogenMessage.Neuron neuron = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_neuron_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_neuron(i), target, stream);
  }

  // repeated .robogenMessage.NeuralConnection connection = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_connection_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_connection(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.Brain)
  return target;
}

size_t Brain::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.Brain)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .robogenMessage.Neuron neuron = 1;
  total_size += 1UL * this->_internal_neuron_size();
  for (const auto& msg : this->neuron_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .robogenMessage.NeuralConnection connection = 2;
  total_size += 1UL * this->_internal_connection_size();
  for (const auto& msg : this->connection_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Brain::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.Brain)
  GOOGLE_DCHECK_NE(&from, this);
  const Brain* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Brain>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.Brain)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.Brain)
    MergeFrom(*source);
  }
}

void Brain::MergeFrom(const Brain& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.Brain)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  neuron_.MergeFrom(from.neuron_);
  connection_.MergeFrom(from.connection_);
}

void Brain::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.Brain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Brain::CopyFrom(const Brain& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.Brain)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Brain::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(neuron_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(connection_)) return false;
  return true;
}

void Brain::InternalSwap(Brain* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  neuron_.InternalSwap(&other->neuron_);
  connection_.InternalSwap(&other->connection_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Brain::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Robot::InitAsDefaultInstance() {
  ::robogenMessage::_Robot_default_instance_._instance.get_mutable()->body_ = const_cast< ::robogenMessage::Body*>(
      ::robogenMessage::Body::internal_default_instance());
  ::robogenMessage::_Robot_default_instance_._instance.get_mutable()->brain_ = const_cast< ::robogenMessage::Brain*>(
      ::robogenMessage::Brain::internal_default_instance());
}
class Robot::_Internal {
 public:
  using HasBits = decltype(std::declval<Robot>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::robogenMessage::Body& body(const Robot* msg);
  static void set_has_body(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::robogenMessage::Brain& brain(const Robot* msg);
  static void set_has_brain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

const ::robogenMessage::Body&
Robot::_Internal::body(const Robot* msg) {
  return *msg->body_;
}
const ::robogenMessage::Brain&
Robot::_Internal::brain(const Robot* msg) {
  return *msg->brain_;
}
Robot::Robot(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.Robot)
}
Robot::Robot(const Robot& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_body()) {
    body_ = new ::robogenMessage::Body(*from.body_);
  } else {
    body_ = nullptr;
  }
  if (from._internal_has_brain()) {
    brain_ = new ::robogenMessage::Brain(*from.brain_);
  } else {
    brain_ = nullptr;
  }
  id_ = from.id_;
  // @@protoc_insertion_point(copy_constructor:robogenMessage.Robot)
}

void Robot::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Robot_robogen_2eproto.base);
  ::memset(&body_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&body_)) + sizeof(id_));
}

Robot::~Robot() {
  // @@protoc_insertion_point(destructor:robogenMessage.Robot)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Robot::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete body_;
  if (this != internal_default_instance()) delete brain_;
}

void Robot::ArenaDtor(void* object) {
  Robot* _this = reinterpret_cast< Robot* >(object);
  (void)_this;
}
void Robot::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Robot::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Robot& Robot::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Robot_robogen_2eproto.base);
  return *internal_default_instance();
}


void Robot::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.Robot)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(body_ != nullptr);
      body_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(brain_ != nullptr);
      brain_->Clear();
    }
  }
  id_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Robot::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .robogenMessage.Body body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_body(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .robogenMessage.Brain brain = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_brain(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Robot::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.Robot)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required .robogenMessage.Body body = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::body(this), target, stream);
  }

  // required .robogenMessage.Brain brain = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::brain(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.Robot)
  return target;
}

size_t Robot::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.Robot)
  size_t total_size = 0;

  if (_internal_has_body()) {
    // required .robogenMessage.Body body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *body_);
  }

  if (_internal_has_brain()) {
    // required .robogenMessage.Brain brain = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *brain_);
  }

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());
  }

  return total_size;
}
size_t Robot::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.Robot)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .robogenMessage.Body body = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *body_);

    // required .robogenMessage.Brain brain = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *brain_);

    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Robot::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  const Robot* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Robot>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.Robot)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.Robot)
    MergeFrom(*source);
  }
}

void Robot::MergeFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.Robot)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_body()->::robogenMessage::Body::MergeFrom(from._internal_body());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_brain()->::robogenMessage::Brain::MergeFrom(from._internal_brain());
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Robot::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Robot::CopyFrom(const Robot& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.Robot)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Robot::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_body()) {
    if (!body_->IsInitialized()) return false;
  }
  if (_internal_has_brain()) {
    if (!brain_->IsInitialized()) return false;
  }
  return true;
}

void Robot::InternalSwap(Robot* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Robot, id_)
      + sizeof(Robot::id_)
      - PROTOBUF_FIELD_OFFSET(Robot, body_)>(
          reinterpret_cast<char*>(&body_),
          reinterpret_cast<char*>(&other->body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Robot::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Obstacle::InitAsDefaultInstance() {
}
class Obstacle::_Internal {
 public:
  using HasBits = decltype(std::declval<Obstacle>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_xsize(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ysize(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_zsize(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_density(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_xrotation(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_yrotation(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_zrotation(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_rotationangle(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x000007ff) ^ 0x000007ff) != 0;
  }
};

Obstacle::Obstacle(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.Obstacle)
}
Obstacle::Obstacle(const Obstacle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&rotationangle_) -
    reinterpret_cast<char*>(&x_)) + sizeof(rotationangle_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.Obstacle)
}

void Obstacle::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rotationangle_) -
      reinterpret_cast<char*>(&x_)) + sizeof(rotationangle_));
}

Obstacle::~Obstacle() {
  // @@protoc_insertion_point(destructor:robogenMessage.Obstacle)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Obstacle::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Obstacle::ArenaDtor(void* object) {
  Obstacle* _this = reinterpret_cast< Obstacle* >(object);
  (void)_this;
}
void Obstacle::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Obstacle::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Obstacle& Obstacle::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Obstacle_robogen_2eproto.base);
  return *internal_default_instance();
}


void Obstacle::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.Obstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&xrotation_) -
        reinterpret_cast<char*>(&x_)) + sizeof(xrotation_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&yrotation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rotationangle_) -
        reinterpret_cast<char*>(&yrotation_)) + sizeof(rotationangle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Obstacle::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float xSize = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 37)) {
          _Internal::set_has_xsize(&has_bits);
          xsize_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float ySize = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 45)) {
          _Internal::set_has_ysize(&has_bits);
          ysize_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float zSize = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_zsize(&has_bits);
          zsize_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float density = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_density(&has_bits);
          density_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float xRotation = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 69)) {
          _Internal::set_has_xrotation(&has_bits);
          xrotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float yRotation = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 77)) {
          _Internal::set_has_yrotation(&has_bits);
          yrotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float zRotation = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_zrotation(&has_bits);
          zrotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float rotationAngle = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_rotationangle(&has_bits);
          rotationangle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Obstacle::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.Obstacle)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // required float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // required float xSize = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_xsize(), target);
  }

  // required float ySize = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_ysize(), target);
  }

  // required float zSize = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_zsize(), target);
  }

  // required float density = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_density(), target);
  }

  // required float xRotation = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_xrotation(), target);
  }

  // required float yRotation = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_yrotation(), target);
  }

  // required float zRotation = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_zrotation(), target);
  }

  // required float rotationAngle = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_rotationangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.Obstacle)
  return target;
}

size_t Obstacle::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.Obstacle)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_xsize()) {
    // required float xSize = 4;
    total_size += 1 + 4;
  }

  if (_internal_has_ysize()) {
    // required float ySize = 5;
    total_size += 1 + 4;
  }

  if (_internal_has_zsize()) {
    // required float zSize = 6;
    total_size += 1 + 4;
  }

  if (_internal_has_density()) {
    // required float density = 7;
    total_size += 1 + 4;
  }

  if (_internal_has_xrotation()) {
    // required float xRotation = 8;
    total_size += 1 + 4;
  }

  if (_internal_has_yrotation()) {
    // required float yRotation = 9;
    total_size += 1 + 4;
  }

  if (_internal_has_zrotation()) {
    // required float zRotation = 10;
    total_size += 1 + 4;
  }

  if (_internal_has_rotationangle()) {
    // required float rotationAngle = 11;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t Obstacle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.Obstacle)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x000007ff) ^ 0x000007ff) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

    // required float xSize = 4;
    total_size += 1 + 4;

    // required float ySize = 5;
    total_size += 1 + 4;

    // required float zSize = 6;
    total_size += 1 + 4;

    // required float density = 7;
    total_size += 1 + 4;

    // required float xRotation = 8;
    total_size += 1 + 4;

    // required float yRotation = 9;
    total_size += 1 + 4;

    // required float zRotation = 10;
    total_size += 1 + 4;

    // required float rotationAngle = 11;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Obstacle::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  const Obstacle* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Obstacle>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.Obstacle)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.Obstacle)
    MergeFrom(*source);
  }
}

void Obstacle::MergeFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.Obstacle)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      xsize_ = from.xsize_;
    }
    if (cached_has_bits & 0x00000010u) {
      ysize_ = from.ysize_;
    }
    if (cached_has_bits & 0x00000020u) {
      zsize_ = from.zsize_;
    }
    if (cached_has_bits & 0x00000040u) {
      density_ = from.density_;
    }
    if (cached_has_bits & 0x00000080u) {
      xrotation_ = from.xrotation_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      yrotation_ = from.yrotation_;
    }
    if (cached_has_bits & 0x00000200u) {
      zrotation_ = from.zrotation_;
    }
    if (cached_has_bits & 0x00000400u) {
      rotationangle_ = from.rotationangle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Obstacle::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Obstacle::CopyFrom(const Obstacle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.Obstacle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Obstacle::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Obstacle::InternalSwap(Obstacle* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Obstacle, rotationangle_)
      + sizeof(Obstacle::rotationangle_)
      - PROTOBUF_FIELD_OFFSET(Obstacle, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Obstacle::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LightSource::InitAsDefaultInstance() {
}
class LightSource::_Internal {
 public:
  using HasBits = decltype(std::declval<LightSource>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_intensity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

LightSource::LightSource(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.LightSource)
}
LightSource::LightSource(const LightSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&intensity_) -
    reinterpret_cast<char*>(&x_)) + sizeof(intensity_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.LightSource)
}

void LightSource::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&intensity_) -
      reinterpret_cast<char*>(&x_)) + sizeof(intensity_));
}

LightSource::~LightSource() {
  // @@protoc_insertion_point(destructor:robogenMessage.LightSource)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LightSource::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LightSource::ArenaDtor(void* object) {
  LightSource* _this = reinterpret_cast< LightSource* >(object);
  (void)_this;
}
void LightSource::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LightSource::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LightSource& LightSource::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LightSource_robogen_2eproto.base);
  return *internal_default_instance();
}


void LightSource::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.LightSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&intensity_) -
        reinterpret_cast<char*>(&x_)) + sizeof(intensity_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LightSource::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float intensity = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 61)) {
          _Internal::set_has_intensity(&has_bits);
          intensity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LightSource::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.LightSource)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // required float z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_z(), target);
  }

  // required float intensity = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_intensity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.LightSource)
  return target;
}

size_t LightSource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.LightSource)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_z()) {
    // required float z = 3;
    total_size += 1 + 4;
  }

  if (_internal_has_intensity()) {
    // required float intensity = 7;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t LightSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.LightSource)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float z = 3;
    total_size += 1 + 4;

    // required float intensity = 7;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LightSource::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.LightSource)
  GOOGLE_DCHECK_NE(&from, this);
  const LightSource* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LightSource>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.LightSource)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.LightSource)
    MergeFrom(*source);
  }
}

void LightSource::MergeFrom(const LightSource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.LightSource)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    if (cached_has_bits & 0x00000008u) {
      intensity_ = from.intensity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LightSource::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.LightSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LightSource::CopyFrom(const LightSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.LightSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LightSource::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void LightSource::InternalSwap(LightSource* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LightSource, intensity_)
      + sizeof(LightSource::intensity_)
      - PROTOBUF_FIELD_OFFSET(LightSource, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LightSource::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void StartPosition::InitAsDefaultInstance() {
}
class StartPosition::_Internal {
 public:
  using HasBits = decltype(std::declval<StartPosition>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_azimuth(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

StartPosition::StartPosition(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.StartPosition)
}
StartPosition::StartPosition(const StartPosition& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&azimuth_) -
    reinterpret_cast<char*>(&x_)) + sizeof(azimuth_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.StartPosition)
}

void StartPosition::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&azimuth_) -
      reinterpret_cast<char*>(&x_)) + sizeof(azimuth_));
}

StartPosition::~StartPosition() {
  // @@protoc_insertion_point(destructor:robogenMessage.StartPosition)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void StartPosition::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void StartPosition::ArenaDtor(void* object) {
  StartPosition* _this = reinterpret_cast< StartPosition* >(object);
  (void)_this;
}
void StartPosition::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void StartPosition::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const StartPosition& StartPosition::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_StartPosition_robogen_2eproto.base);
  return *internal_default_instance();
}


void StartPosition::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.StartPosition)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&azimuth_) -
        reinterpret_cast<char*>(&x_)) + sizeof(azimuth_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StartPosition::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float azimuth = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          _Internal::set_has_azimuth(&has_bits);
          azimuth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* StartPosition::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.StartPosition)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // required float y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // required float azimuth = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_azimuth(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.StartPosition)
  return target;
}

size_t StartPosition::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.StartPosition)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required float x = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_y()) {
    // required float y = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_azimuth()) {
    // required float azimuth = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t StartPosition::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.StartPosition)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required float x = 1;
    total_size += 1 + 4;

    // required float y = 2;
    total_size += 1 + 4;

    // required float azimuth = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StartPosition::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.StartPosition)
  GOOGLE_DCHECK_NE(&from, this);
  const StartPosition* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<StartPosition>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.StartPosition)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.StartPosition)
    MergeFrom(*source);
  }
}

void StartPosition::MergeFrom(const StartPosition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.StartPosition)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      azimuth_ = from.azimuth_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void StartPosition::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.StartPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StartPosition::CopyFrom(const StartPosition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.StartPosition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StartPosition::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void StartPosition::InternalSwap(StartPosition* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StartPosition, azimuth_)
      + sizeof(StartPosition::azimuth_)
      - PROTOBUF_FIELD_OFFSET(StartPosition, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata StartPosition::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void SimulatorConf::InitAsDefaultInstance() {
}
class SimulatorConf::_Internal {
 public:
  using HasBits = decltype(std::declval<SimulatorConf>()._has_bits_);
  static void set_has_terrainwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_terrainlength(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_scenario(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestep(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ntimesteps(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_actuationperiod(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_terrainfriction(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_sensornoiselevel(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_motornoiselevel(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_capacceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_maxlinearacceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_maxangularacceleration(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_maxdirectionshiftspersecond(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_gravityx(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_gravityy(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_gravityz(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_terraintype(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_terrainheight(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_terrainheightfieldfilename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_disallowobstaclecollisions(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_obstacleoverlappolicy(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x001fffff) ^ 0x001fffff) != 0;
  }
};

SimulatorConf::SimulatorConf(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  obstacles_(arena),
  lightsources_(arena),
  startpositions_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.SimulatorConf)
}
SimulatorConf::SimulatorConf(const SimulatorConf& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      obstacles_(from.obstacles_),
      lightsources_(from.lightsources_),
      startpositions_(from.startpositions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  scenario_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_scenario()) {
    scenario_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_scenario(),
      GetArena());
  }
  terrainheightfieldfilename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_terrainheightfieldfilename()) {
    terrainheightfieldfilename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_terrainheightfieldfilename(),
      GetArena());
  }
  ::memcpy(&terrainwidth_, &from.terrainwidth_,
    static_cast<size_t>(reinterpret_cast<char*>(&obstacleoverlappolicy_) -
    reinterpret_cast<char*>(&terrainwidth_)) + sizeof(obstacleoverlappolicy_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.SimulatorConf)
}

void SimulatorConf::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_SimulatorConf_robogen_2eproto.base);
  scenario_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  terrainheightfieldfilename_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&terrainwidth_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&obstacleoverlappolicy_) -
      reinterpret_cast<char*>(&terrainwidth_)) + sizeof(obstacleoverlappolicy_));
}

SimulatorConf::~SimulatorConf() {
  // @@protoc_insertion_point(destructor:robogenMessage.SimulatorConf)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void SimulatorConf::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  scenario_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  terrainheightfieldfilename_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void SimulatorConf::ArenaDtor(void* object) {
  SimulatorConf* _this = reinterpret_cast< SimulatorConf* >(object);
  (void)_this;
}
void SimulatorConf::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SimulatorConf::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const SimulatorConf& SimulatorConf::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_SimulatorConf_robogen_2eproto.base);
  return *internal_default_instance();
}


void SimulatorConf::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.SimulatorConf)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  obstacles_.Clear();
  lightsources_.Clear();
  startpositions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      scenario_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      terrainheightfieldfilename_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&terrainwidth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&terrainfriction_) -
        reinterpret_cast<char*>(&terrainwidth_)) + sizeof(terrainfriction_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&sensornoiselevel_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&capacceleration_) -
        reinterpret_cast<char*>(&sensornoiselevel_)) + sizeof(capacceleration_));
  }
  if (cached_has_bits & 0x001f0000u) {
    ::memset(&disallowobstaclecollisions_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&obstacleoverlappolicy_) -
        reinterpret_cast<char*>(&disallowobstaclecollisions_)) + sizeof(obstacleoverlappolicy_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SimulatorConf::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required float terrainWidth = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 13)) {
          _Internal::set_has_terrainwidth(&has_bits);
          terrainwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float terrainLength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_terrainlength(&has_bits);
          terrainlength_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated .robogenMessage.Obstacle obstacles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_obstacles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // required string scenario = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          auto str = _internal_mutable_scenario();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.SimulatorConf.scenario");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .robogenMessage.LightSource lightSources = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_lightsources(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else goto handle_unusual;
        continue;
      // required float timeStep = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 53)) {
          _Internal::set_has_timestep(&has_bits);
          timestep_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required int32 nTimeSteps = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 56)) {
          _Internal::set_has_ntimesteps(&has_bits);
          ntimesteps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .robogenMessage.StartPosition startPositions = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_startpositions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else goto handle_unusual;
        continue;
      // required int32 actuationPeriod = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          _Internal::set_has_actuationperiod(&has_bits);
          actuationperiod_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float terrainFriction = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 85)) {
          _Internal::set_has_terrainfriction(&has_bits);
          terrainfriction_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float sensorNoiseLevel = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 93)) {
          _Internal::set_has_sensornoiselevel(&has_bits);
          sensornoiselevel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float motorNoiseLevel = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 101)) {
          _Internal::set_has_motornoiselevel(&has_bits);
          motornoiselevel_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required bool capAcceleration = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 104)) {
          _Internal::set_has_capacceleration(&has_bits);
          capacceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float maxLinearAcceleration = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 117)) {
          _Internal::set_has_maxlinearacceleration(&has_bits);
          maxlinearacceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float maxAngularAcceleration = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 125)) {
          _Internal::set_has_maxangularacceleration(&has_bits);
          maxangularacceleration_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required int32 maxDirectionShiftsPerSecond = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 128)) {
          _Internal::set_has_maxdirectionshiftspersecond(&has_bits);
          maxdirectionshiftspersecond_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float gravityX = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 141)) {
          _Internal::set_has_gravityx(&has_bits);
          gravityx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float gravityY = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 149)) {
          _Internal::set_has_gravityy(&has_bits);
          gravityy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required float gravityZ = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 157)) {
          _Internal::set_has_gravityz(&has_bits);
          gravityz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required int32 terrainType = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 160)) {
          _Internal::set_has_terraintype(&has_bits);
          terraintype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float terrainHeight = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 173)) {
          _Internal::set_has_terrainheight(&has_bits);
          terrainheight_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // required string terrainHeightFieldFileName = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 178)) {
          auto str = _internal_mutable_terrainheightfieldfilename();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "robogenMessage.SimulatorConf.terrainHeightFieldFileName");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bool disallowObstacleCollisions = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 184)) {
          _Internal::set_has_disallowobstaclecollisions(&has_bits);
          disallowobstaclecollisions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 obstacleOverlapPolicy = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 192)) {
          _Internal::set_has_obstacleoverlappolicy(&has_bits);
          obstacleoverlappolicy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* SimulatorConf::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.SimulatorConf)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required float terrainWidth = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_terrainwidth(), target);
  }

  // required float terrainLength = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_terrainlength(), target);
  }

  // repeated .robogenMessage.Obstacle obstacles = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_obstacles_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_obstacles(i), target, stream);
  }

  // required string scenario = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_scenario().data(), static_cast<int>(this->_internal_scenario().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.SimulatorConf.scenario");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_scenario(), target);
  }

  // repeated .robogenMessage.LightSource lightSources = 5;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_lightsources_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_lightsources(i), target, stream);
  }

  // required float timeStep = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_timestep(), target);
  }

  // required int32 nTimeSteps = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_ntimesteps(), target);
  }

  // repeated .robogenMessage.StartPosition startPositions = 8;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_startpositions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, this->_internal_startpositions(i), target, stream);
  }

  // required int32 actuationPeriod = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_actuationperiod(), target);
  }

  // required float terrainFriction = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_terrainfriction(), target);
  }

  // required float sensorNoiseLevel = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_sensornoiselevel(), target);
  }

  // required float motorNoiseLevel = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_motornoiselevel(), target);
  }

  // required bool capAcceleration = 13;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_capacceleration(), target);
  }

  // required float maxLinearAcceleration = 14;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_maxlinearacceleration(), target);
  }

  // required float maxAngularAcceleration = 15;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_maxangularacceleration(), target);
  }

  // required int32 maxDirectionShiftsPerSecond = 16;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(16, this->_internal_maxdirectionshiftspersecond(), target);
  }

  // required float gravityX = 17;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_gravityx(), target);
  }

  // required float gravityY = 18;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_gravityy(), target);
  }

  // required float gravityZ = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(19, this->_internal_gravityz(), target);
  }

  // required int32 terrainType = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(20, this->_internal_terraintype(), target);
  }

  // required float terrainHeight = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(21, this->_internal_terrainheight(), target);
  }

  // required string terrainHeightFieldFileName = 22;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_terrainheightfieldfilename().data(), static_cast<int>(this->_internal_terrainheightfieldfilename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "robogenMessage.SimulatorConf.terrainHeightFieldFileName");
    target = stream->WriteStringMaybeAliased(
        22, this->_internal_terrainheightfieldfilename(), target);
  }

  // required bool disallowObstacleCollisions = 23;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_disallowobstaclecollisions(), target);
  }

  // required uint32 obstacleOverlapPolicy = 24;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(24, this->_internal_obstacleoverlappolicy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.SimulatorConf)
  return target;
}

size_t SimulatorConf::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.SimulatorConf)
  size_t total_size = 0;

  if (_internal_has_scenario()) {
    // required string scenario = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scenario());
  }

  if (_internal_has_terrainheightfieldfilename()) {
    // required string terrainHeightFieldFileName = 22;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_terrainheightfieldfilename());
  }

  if (_internal_has_terrainwidth()) {
    // required float terrainWidth = 1;
    total_size += 1 + 4;
  }

  if (_internal_has_terrainlength()) {
    // required float terrainLength = 2;
    total_size += 1 + 4;
  }

  if (_internal_has_timestep()) {
    // required float timeStep = 6;
    total_size += 1 + 4;
  }

  if (_internal_has_ntimesteps()) {
    // required int32 nTimeSteps = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_ntimesteps());
  }

  if (_internal_has_actuationperiod()) {
    // required int32 actuationPeriod = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_actuationperiod());
  }

  if (_internal_has_terrainfriction()) {
    // required float terrainFriction = 10;
    total_size += 1 + 4;
  }

  if (_internal_has_sensornoiselevel()) {
    // required float sensorNoiseLevel = 11;
    total_size += 1 + 4;
  }

  if (_internal_has_motornoiselevel()) {
    // required float motorNoiseLevel = 12;
    total_size += 1 + 4;
  }

  if (_internal_has_maxlinearacceleration()) {
    // required float maxLinearAcceleration = 14;
    total_size += 1 + 4;
  }

  if (_internal_has_maxangularacceleration()) {
    // required float maxAngularAcceleration = 15;
    total_size += 1 + 4;
  }

  if (_internal_has_maxdirectionshiftspersecond()) {
    // required int32 maxDirectionShiftsPerSecond = 16;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_maxdirectionshiftspersecond());
  }

  if (_internal_has_gravityx()) {
    // required float gravityX = 17;
    total_size += 2 + 4;
  }

  if (_internal_has_gravityy()) {
    // required float gravityY = 18;
    total_size += 2 + 4;
  }

  if (_internal_has_capacceleration()) {
    // required bool capAcceleration = 13;
    total_size += 1 + 1;
  }

  if (_internal_has_disallowobstaclecollisions()) {
    // required bool disallowObstacleCollisions = 23;
    total_size += 2 + 1;
  }

  if (_internal_has_gravityz()) {
    // required float gravityZ = 19;
    total_size += 2 + 4;
  }

  if (_internal_has_terraintype()) {
    // required int32 terrainType = 20;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_terraintype());
  }

  if (_internal_has_terrainheight()) {
    // required float terrainHeight = 21;
    total_size += 2 + 4;
  }

  if (_internal_has_obstacleoverlappolicy()) {
    // required uint32 obstacleOverlapPolicy = 24;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_obstacleoverlappolicy());
  }

  return total_size;
}
size_t SimulatorConf::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.SimulatorConf)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x001fffff) ^ 0x001fffff) == 0) {  // All required fields are present.
    // required string scenario = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_scenario());

    // required string terrainHeightFieldFileName = 22;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_terrainheightfieldfilename());

    // required float terrainWidth = 1;
    total_size += 1 + 4;

    // required float terrainLength = 2;
    total_size += 1 + 4;

    // required float timeStep = 6;
    total_size += 1 + 4;

    // required int32 nTimeSteps = 7;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_ntimesteps());

    // required int32 actuationPeriod = 9;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_actuationperiod());

    // required float terrainFriction = 10;
    total_size += 1 + 4;

    // required float sensorNoiseLevel = 11;
    total_size += 1 + 4;

    // required float motorNoiseLevel = 12;
    total_size += 1 + 4;

    // required float maxLinearAcceleration = 14;
    total_size += 1 + 4;

    // required float maxAngularAcceleration = 15;
    total_size += 1 + 4;

    // required int32 maxDirectionShiftsPerSecond = 16;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_maxdirectionshiftspersecond());

    // required float gravityX = 17;
    total_size += 2 + 4;

    // required float gravityY = 18;
    total_size += 2 + 4;

    // required bool capAcceleration = 13;
    total_size += 1 + 1;

    // required bool disallowObstacleCollisions = 23;
    total_size += 2 + 1;

    // required float gravityZ = 19;
    total_size += 2 + 4;

    // required int32 terrainType = 20;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_terraintype());

    // required float terrainHeight = 21;
    total_size += 2 + 4;

    // required uint32 obstacleOverlapPolicy = 24;
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_obstacleoverlappolicy());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .robogenMessage.Obstacle obstacles = 3;
  total_size += 1UL * this->_internal_obstacles_size();
  for (const auto& msg : this->obstacles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .robogenMessage.LightSource lightSources = 5;
  total_size += 1UL * this->_internal_lightsources_size();
  for (const auto& msg : this->lightsources_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .robogenMessage.StartPosition startPositions = 8;
  total_size += 1UL * this->_internal_startpositions_size();
  for (const auto& msg : this->startpositions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SimulatorConf::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.SimulatorConf)
  GOOGLE_DCHECK_NE(&from, this);
  const SimulatorConf* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<SimulatorConf>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.SimulatorConf)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.SimulatorConf)
    MergeFrom(*source);
  }
}

void SimulatorConf::MergeFrom(const SimulatorConf& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.SimulatorConf)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  obstacles_.MergeFrom(from.obstacles_);
  lightsources_.MergeFrom(from.lightsources_);
  startpositions_.MergeFrom(from.startpositions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_scenario(from._internal_scenario());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_terrainheightfieldfilename(from._internal_terrainheightfieldfilename());
    }
    if (cached_has_bits & 0x00000004u) {
      terrainwidth_ = from.terrainwidth_;
    }
    if (cached_has_bits & 0x00000008u) {
      terrainlength_ = from.terrainlength_;
    }
    if (cached_has_bits & 0x00000010u) {
      timestep_ = from.timestep_;
    }
    if (cached_has_bits & 0x00000020u) {
      ntimesteps_ = from.ntimesteps_;
    }
    if (cached_has_bits & 0x00000040u) {
      actuationperiod_ = from.actuationperiod_;
    }
    if (cached_has_bits & 0x00000080u) {
      terrainfriction_ = from.terrainfriction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      sensornoiselevel_ = from.sensornoiselevel_;
    }
    if (cached_has_bits & 0x00000200u) {
      motornoiselevel_ = from.motornoiselevel_;
    }
    if (cached_has_bits & 0x00000400u) {
      maxlinearacceleration_ = from.maxlinearacceleration_;
    }
    if (cached_has_bits & 0x00000800u) {
      maxangularacceleration_ = from.maxangularacceleration_;
    }
    if (cached_has_bits & 0x00001000u) {
      maxdirectionshiftspersecond_ = from.maxdirectionshiftspersecond_;
    }
    if (cached_has_bits & 0x00002000u) {
      gravityx_ = from.gravityx_;
    }
    if (cached_has_bits & 0x00004000u) {
      gravityy_ = from.gravityy_;
    }
    if (cached_has_bits & 0x00008000u) {
      capacceleration_ = from.capacceleration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      disallowobstaclecollisions_ = from.disallowobstaclecollisions_;
    }
    if (cached_has_bits & 0x00020000u) {
      gravityz_ = from.gravityz_;
    }
    if (cached_has_bits & 0x00040000u) {
      terraintype_ = from.terraintype_;
    }
    if (cached_has_bits & 0x00080000u) {
      terrainheight_ = from.terrainheight_;
    }
    if (cached_has_bits & 0x00100000u) {
      obstacleoverlappolicy_ = from.obstacleoverlappolicy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void SimulatorConf::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.SimulatorConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SimulatorConf::CopyFrom(const SimulatorConf& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.SimulatorConf)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SimulatorConf::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(obstacles_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(lightsources_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(startpositions_)) return false;
  return true;
}

void SimulatorConf::InternalSwap(SimulatorConf* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  obstacles_.InternalSwap(&other->obstacles_);
  lightsources_.InternalSwap(&other->lightsources_);
  startpositions_.InternalSwap(&other->startpositions_);
  scenario_.Swap(&other->scenario_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  terrainheightfieldfilename_.Swap(&other->terrainheightfieldfilename_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SimulatorConf, obstacleoverlappolicy_)
      + sizeof(SimulatorConf::obstacleoverlappolicy_)
      - PROTOBUF_FIELD_OFFSET(SimulatorConf, terrainwidth_)>(
          reinterpret_cast<char*>(&terrainwidth_),
          reinterpret_cast<char*>(&other->terrainwidth_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SimulatorConf::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void EvaluationRequest::InitAsDefaultInstance() {
  ::robogenMessage::_EvaluationRequest_default_instance_._instance.get_mutable()->robot_ = const_cast< ::robogenMessage::Robot*>(
      ::robogenMessage::Robot::internal_default_instance());
  ::robogenMessage::_EvaluationRequest_default_instance_._instance.get_mutable()->configuration_ = const_cast< ::robogenMessage::SimulatorConf*>(
      ::robogenMessage::SimulatorConf::internal_default_instance());
}
class EvaluationRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<EvaluationRequest>()._has_bits_);
  static const ::robogenMessage::Robot& robot(const EvaluationRequest* msg);
  static void set_has_robot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::robogenMessage::SimulatorConf& configuration(const EvaluationRequest* msg);
  static void set_has_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

const ::robogenMessage::Robot&
EvaluationRequest::_Internal::robot(const EvaluationRequest* msg) {
  return *msg->robot_;
}
const ::robogenMessage::SimulatorConf&
EvaluationRequest::_Internal::configuration(const EvaluationRequest* msg) {
  return *msg->configuration_;
}
EvaluationRequest::EvaluationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.EvaluationRequest)
}
EvaluationRequest::EvaluationRequest(const EvaluationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_robot()) {
    robot_ = new ::robogenMessage::Robot(*from.robot_);
  } else {
    robot_ = nullptr;
  }
  if (from._internal_has_configuration()) {
    configuration_ = new ::robogenMessage::SimulatorConf(*from.configuration_);
  } else {
    configuration_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:robogenMessage.EvaluationRequest)
}

void EvaluationRequest::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_EvaluationRequest_robogen_2eproto.base);
  ::memset(&robot_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&configuration_) -
      reinterpret_cast<char*>(&robot_)) + sizeof(configuration_));
}

EvaluationRequest::~EvaluationRequest() {
  // @@protoc_insertion_point(destructor:robogenMessage.EvaluationRequest)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EvaluationRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete robot_;
  if (this != internal_default_instance()) delete configuration_;
}

void EvaluationRequest::ArenaDtor(void* object) {
  EvaluationRequest* _this = reinterpret_cast< EvaluationRequest* >(object);
  (void)_this;
}
void EvaluationRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EvaluationRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EvaluationRequest& EvaluationRequest::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EvaluationRequest_robogen_2eproto.base);
  return *internal_default_instance();
}


void EvaluationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.EvaluationRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(robot_ != nullptr);
      robot_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(configuration_ != nullptr);
      configuration_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EvaluationRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .robogenMessage.Robot robot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .robogenMessage.SimulatorConf configuration = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_configuration(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EvaluationRequest::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.EvaluationRequest)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .robogenMessage.Robot robot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::robot(this), target, stream);
  }

  // required .robogenMessage.SimulatorConf configuration = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::configuration(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.EvaluationRequest)
  return target;
}

size_t EvaluationRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.EvaluationRequest)
  size_t total_size = 0;

  if (_internal_has_robot()) {
    // required .robogenMessage.Robot robot = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *robot_);
  }

  if (_internal_has_configuration()) {
    // required .robogenMessage.SimulatorConf configuration = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *configuration_);
  }

  return total_size;
}
size_t EvaluationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.EvaluationRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .robogenMessage.Robot robot = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *robot_);

    // required .robogenMessage.SimulatorConf configuration = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *configuration_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EvaluationRequest::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.EvaluationRequest)
  GOOGLE_DCHECK_NE(&from, this);
  const EvaluationRequest* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EvaluationRequest>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.EvaluationRequest)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.EvaluationRequest)
    MergeFrom(*source);
  }
}

void EvaluationRequest::MergeFrom(const EvaluationRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.EvaluationRequest)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_robot()->::robogenMessage::Robot::MergeFrom(from._internal_robot());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_configuration()->::robogenMessage::SimulatorConf::MergeFrom(from._internal_configuration());
    }
  }
}

void EvaluationRequest::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.EvaluationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EvaluationRequest::CopyFrom(const EvaluationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.EvaluationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EvaluationRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_robot()) {
    if (!robot_->IsInitialized()) return false;
  }
  if (_internal_has_configuration()) {
    if (!configuration_->IsInitialized()) return false;
  }
  return true;
}

void EvaluationRequest::InternalSwap(EvaluationRequest* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EvaluationRequest, configuration_)
      + sizeof(EvaluationRequest::configuration_)
      - PROTOBUF_FIELD_OFFSET(EvaluationRequest, robot_)>(
          reinterpret_cast<char*>(&robot_),
          reinterpret_cast<char*>(&other->robot_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EvaluationRequest::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void EvaluationResult::InitAsDefaultInstance() {
}
class EvaluationResult::_Internal {
 public:
  using HasBits = decltype(std::declval<EvaluationResult>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fitness(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

EvaluationResult::EvaluationResult(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  objectives_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:robogenMessage.EvaluationResult)
}
EvaluationResult::EvaluationResult(const EvaluationResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      objectives_(from.objectives_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&fitness_) -
    reinterpret_cast<char*>(&id_)) + sizeof(fitness_));
  // @@protoc_insertion_point(copy_constructor:robogenMessage.EvaluationResult)
}

void EvaluationResult::SharedCtor() {
  ::memset(&id_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&fitness_) -
      reinterpret_cast<char*>(&id_)) + sizeof(fitness_));
}

EvaluationResult::~EvaluationResult() {
  // @@protoc_insertion_point(destructor:robogenMessage.EvaluationResult)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void EvaluationResult::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void EvaluationResult::ArenaDtor(void* object) {
  EvaluationResult* _this = reinterpret_cast< EvaluationResult* >(object);
  (void)_this;
}
void EvaluationResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void EvaluationResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const EvaluationResult& EvaluationResult::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_EvaluationResult_robogen_2eproto.base);
  return *internal_default_instance();
}


void EvaluationResult::Clear() {
// @@protoc_insertion_point(message_clear_start:robogenMessage.EvaluationResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  objectives_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fitness_) -
        reinterpret_cast<char*>(&id_)) + sizeof(fitness_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EvaluationResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required float fitness = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 21)) {
          _Internal::set_has_fitness(&has_bits);
          fitness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else goto handle_unusual;
        continue;
      // repeated float objectives = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 29)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_objectives(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<29>(ptr));
        } else if (static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_objectives(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* EvaluationResult::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:robogenMessage.EvaluationResult)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // required float fitness = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_fitness(), target);
  }

  // repeated float objectives = 3;
  for (int i = 0, n = this->_internal_objectives_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_objectives(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:robogenMessage.EvaluationResult)
  return target;
}

size_t EvaluationResult::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:robogenMessage.EvaluationResult)
  size_t total_size = 0;

  if (_internal_has_id()) {
    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());
  }

  if (_internal_has_fitness()) {
    // required float fitness = 2;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t EvaluationResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:robogenMessage.EvaluationResult)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int32 id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_id());

    // required float fitness = 2;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float objectives = 3;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_objectives_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_objectives_size());
    total_size += data_size;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EvaluationResult::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:robogenMessage.EvaluationResult)
  GOOGLE_DCHECK_NE(&from, this);
  const EvaluationResult* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<EvaluationResult>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:robogenMessage.EvaluationResult)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:robogenMessage.EvaluationResult)
    MergeFrom(*source);
  }
}

void EvaluationResult::MergeFrom(const EvaluationResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:robogenMessage.EvaluationResult)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  objectives_.MergeFrom(from.objectives_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      fitness_ = from.fitness_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void EvaluationResult::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:robogenMessage.EvaluationResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void EvaluationResult::CopyFrom(const EvaluationResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:robogenMessage.EvaluationResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EvaluationResult::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void EvaluationResult::InternalSwap(EvaluationResult* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  objectives_.InternalSwap(&other->objectives_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EvaluationResult, fitness_)
      + sizeof(EvaluationResult::fitness_)
      - PROTOBUF_FIELD_OFFSET(EvaluationResult, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata EvaluationResult::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace robogenMessage
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::robogenMessage::EvolvableParameter* Arena::CreateMaybeMessage< ::robogenMessage::EvolvableParameter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::EvolvableParameter >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::BodyPart* Arena::CreateMaybeMessage< ::robogenMessage::BodyPart >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::BodyPart >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::BodyConnection* Arena::CreateMaybeMessage< ::robogenMessage::BodyConnection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::BodyConnection >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::Body* Arena::CreateMaybeMessage< ::robogenMessage::Body >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::Body >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::NeuralConnection* Arena::CreateMaybeMessage< ::robogenMessage::NeuralConnection >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::NeuralConnection >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::Neuron* Arena::CreateMaybeMessage< ::robogenMessage::Neuron >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::Neuron >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::Brain* Arena::CreateMaybeMessage< ::robogenMessage::Brain >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::Brain >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::Robot* Arena::CreateMaybeMessage< ::robogenMessage::Robot >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::Robot >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::Obstacle* Arena::CreateMaybeMessage< ::robogenMessage::Obstacle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::Obstacle >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::LightSource* Arena::CreateMaybeMessage< ::robogenMessage::LightSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::LightSource >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::StartPosition* Arena::CreateMaybeMessage< ::robogenMessage::StartPosition >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::StartPosition >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::SimulatorConf* Arena::CreateMaybeMessage< ::robogenMessage::SimulatorConf >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::SimulatorConf >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::EvaluationRequest* Arena::CreateMaybeMessage< ::robogenMessage::EvaluationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::EvaluationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::robogenMessage::EvaluationResult* Arena::CreateMaybeMessage< ::robogenMessage::EvaluationResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::robogenMessage::EvaluationResult >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
